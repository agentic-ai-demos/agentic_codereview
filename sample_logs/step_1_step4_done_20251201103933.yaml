ai_generated_smell: true
breaking_change_risk: low
category: reliability
code_snippet: "if not reserve_max_layer and device_map:\n    if set(device_map.values())\
  \ == {\"cpu\"} or set(device_map.values()) == {\"cpu\", \"disk\"}:\n        main_device\
  \ = \"cpu\"\n    else:\n        main_device_candidates = [d for d in device_map.values()\
  \ if d not in [\"cpu\", \"disk\"]]\n        if not main_device_candidates:\n   \
  \         return device_map\n        main_device = main_device_candidates[0]\n \
  \   offloaded_devices = [\"disk\"] if main_device == \"cpu\" or main_device == \"\
  mps\" else [\"cpu\", \"disk\"]\n    if any(device in offloaded_devices for device\
  \ in device_map.values()):\n        return infer_auto_device_map(\n            model,\n\
  \            max_memory=None,\n            no_split_module_classes=None,\n     \
  \       reserve_max_layer=True,\n            dtype=None,\n            special_dtypes=None,\n\
  \            verbose=False,\n            clean_result=False,\n            offload_buffers=False,\n\
  \            fallback_allocation=False,\n            recursion_depth=recursion_depth\
  \ + 1\n        )"
cwe: 'CWE-674: Uncontrolled Recursion'
file: src/accelerate/utils/modeling.py
fix:
  patch: '- # Define maximum recursion depth

    - MAX_RECURSION_DEPTH = 3

    - def infer_auto_device_map(

    -     model,

    -     max_memory=None,

    -     no_split_module_classes=None,

    -     reserve_max_layer=False,

    -     dtype=None,

    -     special_dtypes=None,

    -     verbose=False,

    -     clean_result=False,

    -     offload_buffers=False,

    -     fallback_allocation=False,

    -     recursion_depth=0

    - ):

    -     if recursion_depth > 3:

    -         if verbose:

    -             print("Max recursion depth reached, returning current device map.")

    -         return device_map

    -     # existing logic

    -     if not reserve_max_layer and device_map:

    -         if set(device_map.values()) == {"cpu"} or set(device_map.values()) ==
    {"cpu", "disk"}:

    -             main_device = "cpu"

    -         else:

    -             main_device_candidates = [d for d in device_map.values() if d not
    in ["cpu", "disk"]]

    -             if not main_device_candidates:

    -                 return device_map

    -             main_device = main_device_candidates[0]

    -         offloaded_devices = ["disk"] if main_device == "cpu" or main_device
    == "mps" else ["cpu", "disk"]

    -         if any(device in offloaded_devices for device in device_map.values()):

    -             return infer_auto_device_map(

    -                 model,

    -                 max_memory=None,

    -                 no_split_module_classes=None,

    -                 reserve_max_layer=True,

    -                 dtype=None,

    -                 special_dtypes=None,

    -                 verbose=False,

    -                 clean_result=False,

    -                 offload_buffers=False,

    -                 fallback_allocation=False,

    -                 recursion_depth=recursion_depth + 1

    -             )'
  strategy: Add a recursion depth safeguard and refine offload detection logic.
lines: 1526-1571
migration_notes: Update to imply the recursive call includes depth limit safeguard.
owasp_top10: N/A
references:
- https://cwe.mitre.org/data/definitions/674.html
root_cause: The condition for recursion depends on device_map analysis which may not
  fully capture dynamic or complex offloading states.
scorecard:
  documentation_and_naming: 3
  extensibility: 3
  maintainability: 3
  performance_complexity: 3
  reliability: 2
  security: 2
  test_quality_and_coverage: 2
severity: high
tests:
  cases:
  - offloaded layers without change in device_map across recursive calls
  - complex device configurations with mixed offloading
  - max recursion depth enforcement
  - normal operation without offloading or recursion
  new_or_changed:
  - test_disconnect_offloading_detection
title: Potential infinite recursion with offloaded device map detection
why_it_matters: Recursive invocation can lead to infinite calls if device_map states
  do not change, risking stack overflow and service crash.
